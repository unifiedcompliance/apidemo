// This function takes data model json and returns a non-nested array.
// The call format is ConvertToNonNestedJSON(path;json) where 
// usage is ConvertToNonNestedJSON("";field name of schema)While ( [// Initial Values	~json = json;  									// this is just taking the json passed in and putting in into a local variable for readability	~path = 	path ;								// take the json path string and put it into a local variable for readability	~extendedPath = Case ( IsEmpty ( ~path ) ; "" ; ~path & "." ) ;  // add a dot to the string for passing into next pass of recursion, unless string was not passed in	// loop control variables	~keys = JSONListKeys ( ~json ; "" ) ;  					// get our list of JSON keys from the object	~keyCount = Case ( Left ( ~keys ; 1 ) = "?" or IsEmpty ( ~keys ) ; 0 ; ValueCount ( ~keys ) ) ;  // get the count of the keys for looping	~n = 1 ;										// loop control variable	// initialize variables that are actually reset during each loop iteration	~thisKey = "" ;									// the current key we are on	~thisValue = "" ;								// current value associated with current key	~isTable = "" ;									// boolean indicating whether the current key is a table name	~isSet = "" ;									// boolean indicating whether the current value is a @set array	~isArrayElement = "" ;							// boolean indicating whether the current value is an element of an indexed array	~isJSON = "" ;									// boolean indicating whether the current value is a  JSON object	~result = "" ;	 								// the result which will eventually be passed out of the function	~fields = "" ;									// the fields in the current table	~extendedPath = Case ( IsEmpty ( ~path ) ; "" ; ~path & "." ) ;	~pathList = Substitute ( ~path ; "." ; ¶ ) ;	~lastInPath = GetValue ( ~pathList ; ValueCount ( ~pathList ) ) ;	~thisTable = Case ( 					IsEmpty ( ~path ) and Left ( JSONGetElement ( ~json ; "@set" ) ; 1 ) ≠ "?" ; JSONGetElement ( ~json ; "@type" ); 					not IsEmpty ( JSONGetElement ( ~json ; "@set" ) ) and Left ( JSONGetElement ( ~json ; "@set" ) ; 1 ) ≠ "?" ; JSONGetElement ( ~json ; "@type" ) ;					GetValue ( ~pathList ; ValueCount ( ~pathList ) )  				) ;	~parentTable = Case ( 						IsEmpty ( ~lastInPath ) ; "" ;						~lastInPath = ~thisTable  and ValueCount ( ~pathList ) > 1 ; GetValue ( ~pathList ; ValueCount ( ~pathList ) - 1 ) ;						~lastInPath = ~thisTable ; "" ;						~lastInPath					) ;	~thisPath = Case (					~parentTable = ~thisTable; ~path ;					~path = ~thisTable ; ~path ;					~lastInPath = ~thisTable ; ~path ;					~extendedPath & ~thisTable				) ;	~baseJSON = JSONSetElement ( "" ; 				 				[ "table" ; ~thisPath ; JSONString ]  			) ];// Loop control conditional	~n ≤ ~keyCount ;[// Loop Iteration 	~thisKey = GetValue ( ~keys ; ~n ) ; 	~thisValue = JSONGetElement ( ~json ; ~thisKey ) ;	~isTable = Left ( JSONGetElement ( ~thisValue ; "@set" ) ; 1 ) ≠ "?" and not IsEmpty ( JSONGetElement ( ~thisValue ; "@set" ) ) ;	~isSet = ~thisKey = "@set" ;	~isArrayElement = IsEmpty ( 		Substitute ( ~thisKey ; 			[ 0 ; "" ] ; 			[ 1 ; "" ] ; 			[ 2 ; "" ] ; 			[ 3 ; "" ] ; 			[ 4 ; "" ] ; 			[ 5 ; "" ] ; 			[ 6 ; "" ] ; 			[ 7 ; "" ] ; 			[ 8 ; "" ] ; 			[ 9 ; "" ] 		) 	) ; // if there's nothing but numerical digits, assume we've got a number	~isJSON = Left ( JSONFormatElements ( ~thisValue ) ; 1 ) ≠ "?" and not IsEmpty ( ~thisValue ) ;	// If we are going to have a next iteration, go ahead and get it	~nextIteration = Case (		~isJSON ; ConvertToNonNestedJSON ( ~thisPath ; ~thisValue ) ;		//else		""	) ;	// Get any fields passed back by the next iteration.  The result is passed back as json with lines and fields keys	~nextIterationFields = Case ( 		~isJSON; ConvertToNonNestedJSON ( ~thisPath ; ~thisValue ) ;		""		) ;	~fields = Case ( 		not IsEmpty ( ~nextIterationFields ) ;  Let ( [										~error1 = Left (JSONFormatElements ( ~fields ) ; 1 ) ≠ "["  and not IsEmpty ( ~fields ) ;										~error2 = Left (JSONFormatElements ( ~nextIterationFields ) ; 1 ) ≠ "["  and not IsEmpty ( ~nextIterationFields );										~combinedArrays = Left ( ~fields ; Length ( ~fields ) - 1 ) & "," & Right ( ~nextIterationFields ; Length ( ~nextIterationFields ) - 1 )									]; 										Case (   											~error1 or ~error2 ; "error" ;   											IsEmpty ( ~fields ) ; ~nextIterationFields ;  											IsEmpty ( ~nextIterationFields ) ; ~fields ;  											~combinedarrays 										 )									) ;		Let ( [			#theArray = Case (					IsEmpty ( ~fields ) 					or					~fields = "{}" ; "[]" ;                            	~fields				) ;				#index = Case ( IsEmpty ( ~fields ) ; 0 ; ValueCount ( JSONListKeys ( ~fields ; "" )  ) ) ;				#error = Case ( Left ( #index ; 1 ) = "?" ; "Invalid Array" ) ;				#thisField = JSONSetElement ( ~baseJSON ;  										[ "field" ; ~thisKey ; JSONString ] ; 										[ "type" ; ~thisValue ; JSONString ] 									)			]; 				Case (  						~thisKey = "@type" or ~thisKey = "@context" ; ~fields ;  						JSONSetElement ( #theArray ; #index ; #thisField ; JSONObject ) 				)		) 			); 	~n = ~n + 1 ];~fields)